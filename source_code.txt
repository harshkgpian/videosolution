===== C:\Users\MSI\Desktop\PW\videosolution\index.html ===== 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Drawing & Recording Canvas</title>
    <!-- NEW: Add this line to link your new icon -->
  <link rel="icon" type="image/svg+xml" href="images/logo.png">

  <!-- CSS -->
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/toolbar.css">
  <link rel="stylesheet" href="css/canvas.css">
  <link rel="stylesheet" href="css/modal.css">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>

  <!-- Sidebar (No changes here) -->
  <aside class="sidebar">
    <div class="tool-group">
      <h4>Tools</h4>
      <button id="selectTool" title="Select Tool (V)"><i class="fa-solid fa-hand-pointer"></i><span>Select</span></button>
      <button id="pencil" class="active" title="Pencil (P)"><i class="fa-solid fa-pencil"></i><span>Pencil</span></button>
      <button id="eraser" title="Eraser (E)"><i class="fa-solid fa-eraser"></i><span>Eraser</span></button>
    </div>
    <div class="tool-group">
        <h4>Actions</h4>
        <div class="control-row">
            <button id="recordBtn" title="Record"><i class="fa-solid fa-microphone"></i><span>Record</span></button>
            <button id="stopBtn" title="Stop Recording" style="display: none;"><i class="fa-solid fa-stop"></i></button>
        </div>
        <canvas id="waveformCanvas" width="180" height="30"></canvas>
    </div>
    <div class="tool-group">
      <h4>Brush</h4>
      <div class="control-row"><div class="control-item"><label for="size">Size</label><select id="size" title="Brush Size"><option value="1.5">XF</option><option value="2.5" selected>F</option><option value="5">M</option><option value="7">T</option><option value="12">XT</option></select></div><div class="control-item"><label for="color">Color</label><select id="color" title="Color"><option value="#000000">âš«</option><option value="#1e40af">ðŸ”µ</option><option value="#dc2626">ðŸ”´</option><option value="#047857">ðŸŸ¢</option></select></div></div>
    </div>
    <div class="tool-group">
      <h4>Objects</h4>
       <button id="addImageBtn" title="Add Image"><i class="fa-solid fa-image"></i><span>Add Image</span></button><input type="file" id="imageInput" accept="image/*" style="display:none;">
      <button id="addBackgroundBtn" title="Add Background"><i class="fa-solid fa-file-image"></i><span>Set BG</span></button><input type="file" id="backgroundInput" accept="image/*" style="display:none;">
      <button id="removeBackgroundBtn" title="Remove Background"><i class="fa-solid fa-ban"></i><span>Clear BG</span></button>
    </div>
    <div class="tool-group">
      <h4>Navigation</h4>
      <div class="control-row page-nav-buttons"><button id="prevPage" title="Previous Page"><i class="fa-solid fa-chevron-left"></i></button><button id="nextPage" title="Next Page"><i class="fa-solid fa-chevron-right"></i></button></div>
      <span id="pageInfo">Page 1 of 1</span>
    </div>
    <div class="tool-group">
      <h4>File</h4>
      <button id="savePdf" title="Save as PDF (Ctrl+S)"><i class="fa-solid fa-file-pdf"></i><span>Save PDF</span></button>
      <button id="customCanvasBtn" title="Canvas Size"><i class="fa-solid fa-ruler-combined"></i><span>Canvas Size</span></button>
    </div>
  </aside>

  <!-- Main Content Area (No changes here) -->
  <main class="main-content">
    <div class="canvas-container"><canvas id="drawingCanvas"></canvas></div>
  </main>

  <!-- Modals -->
  <div id="canvasSizeModal" class="modal">
    <div class="modal-content">
      <h3>Custom Canvas Size</h3>
      <div><label for="canvasWidth">Width (px):</label><input type="number" id="canvasWidth" min="100" max="4000" value="1280"></div>
      <div><label for="canvasHeight">Height (px):</label><input type="number" id="canvasHeight" min="100" max="4000" value="720"></div>
      <button id="setBrowserSize" style="width: 100%; margin: 10px 0;">Set to Browser Size</button>
      <p>Note: Changing canvas size will clear the current drawing.</p>
      <div class="modal-buttons"><button id="cancelCanvasSize" class="btn-secondary">Cancel</button><button id="confirmCanvasSize">Apply</button></div>
    </div>
  </div>

  <div id="filenameModal" class="modal">
    <div class="modal-content">
      <h3>Save Drawing as PDF</h3>
      <div><label for="filenameInput">Filename:</label><input type="text" id="filenameInput" placeholder="drawing.pdf"></div>
      <div class="modal-buttons"><button id="cancelSave" class="btn-secondary">Cancel</button><button id="confirmSave">Save</button></div>
    </div>
  </div>

  <!-- NEW: Modal for saving the recording -->
  <div id="recordingNameModal" class="modal">
    <div class="modal-content">
      <h3>Save Recording</h3>
      <div>
        <label for="recordingNameInput">Filename:</label>
        <input type="text" id="recordingNameInput" placeholder="recording.webm">
      </div>
      <div class="modal-buttons">
        <button id="cancelRecordingSave" class="btn-secondary">Discard</button>
        <button id="confirmRecordingSave">Save</button>
      </div>
    </div>
  </div>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <!-- Main Application Script -->
  <script src="js/main.js" type="module"></script>
</body>
</html>
===== C:\Users\MSI\Desktop\PW\videosolution\README.md ===== 
"# videosolution" 

===== C:\Users\MSI\Desktop\PW\videosolution\source_code.txt ===== 
===== C:\Users\MSI\Desktop\PW\videosolution\index.html ===== 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Drawing & Recording Canvas</title>
    <!-- NEW: Add this line to link your new icon -->
  <link rel="icon" type="image/svg+xml" href="images/logo.png">

  <!-- CSS -->
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/toolbar.css">
  <link rel="stylesheet" href="css/canvas.css">
  <link rel="stylesheet" href="css/modal.css">

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>

  <!-- Sidebar (No changes here) -->
  <aside class="sidebar">
    <div class="tool-group">
      <h4>Tools</h4>
      <button id="selectTool" title="Select Tool (V)"><i class="fa-solid fa-hand-pointer"></i><span>Select</span></button>
      <button id="pencil" class="active" title="Pencil (P)"><i class="fa-solid fa-pencil"></i><span>Pencil</span></button>
      <button id="eraser" title="Eraser (E)"><i class="fa-solid fa-eraser"></i><span>Eraser</span></button>
    </div>
    <div class="tool-group">
        <h4>Actions</h4>
        <div class="control-row">
            <button id="recordBtn" title="Record"><i class="fa-solid fa-microphone"></i><span>Record</span></button>
            <button id="stopBtn" title="Stop Recording" style="display: none;"><i class="fa-solid fa-stop"></i></button>
        </div>
        <canvas id="waveformCanvas" width="180" height="30"></canvas>
    </div>
    <div class="tool-group">
      <h4>Brush</h4>
      <div class="control-row"><div class="control-item"><label for="size">Size</label><select id="size" title="Brush Size"><option value="1.5">XF</option><option value="2.5" selected>F</option><option value="5">M</option><option value="7">T</option><option value="12">XT</option></select></div><div class="control-item"><label for="color">Color</label><select id="color" title="Color"><option value="#000000">âš«</option><option value="#1e40af">ðŸ”µ</option><option value="#dc2626">ðŸ”´</option><option value="#047857">ðŸŸ¢</option></select></div></div>
    </div>
    <div class="tool-group">
      <h4>Objects</h4>
       <button id="addImageBtn" title="Add Image"><i class="fa-solid fa-image"></i><span>Add Image</span></button><input type="file" id="imageInput" accept="image/*" style="display:none;">
      <button id="addBackgroundBtn" title="Add Background"><i class="fa-solid fa-file-image"></i><span>Set BG</span></button><input type="file" id="backgroundInput" accept="image/*" style="display:none;">
      <button id="removeBackgroundBtn" title="Remove Background"><i class="fa-solid fa-ban"></i><span>Clear BG</span></button>
    </div>
    <div class="tool-group">
      <h4>Navigation</h4>
      <div class="control-row page-nav-buttons"><button id="prevPage" title="Previous Page"><i class="fa-solid fa-chevron-left"></i></button><button id="nextPage" title="Next Page"><i class="fa-solid fa-chevron-right"></i></button></div>
      <span id="pageInfo">Page 1 of 1</span>
    </div>
    <div class="tool-group">
      <h4>File</h4>
      <button id="savePdf" title="Save as PDF (Ctrl+S)"><i class="fa-solid fa-file-pdf"></i><span>Save PDF</span></button>
      <button id="customCanvasBtn" title="Canvas Size"><i class="fa-solid fa-ruler-combined"></i><span>Canvas Size</span></button>
    </div>
  </aside>

  <!-- Main Content Area (No changes here) -->
  <main class="main-content">
    <div class="canvas-container"><canvas id="drawingCanvas"></canvas></div>
  </main>

  <!-- Modals -->
  <div id="canvasSizeModal" class="modal">
    <div class="modal-content">
      <h3>Custom Canvas Size</h3>
      <div><label for="canvasWidth">Width (px):</label><input type="number" id="canvasWidth" min="100" max="4000" value="1280"></div>
      <div><label for="canvasHeight">Height (px):</label><input type="number" id="canvasHeight" min="100" max="4000" value="720"></div>
      <button id="setBrowserSize" style="width: 100%; margin: 10px 0;">Set to Browser Size</button>
      <p>Note: Changing canvas size will clear the current drawing.</p>
      <div class="modal-buttons"><button id="cancelCanvasSize" class="btn-secondary">Cancel</button><button id="confirmCanvasSize">Apply</button></div>
    </div>
  </div>

  <div id="filenameModal" class="modal">
    <div class="modal-content">
      <h3>Save Drawing as PDF</h3>
      <div><label for="filenameInput">Filename:</label><input type="text" id="filenameInput" placeholder="drawing.pdf"></div>
      <div class="modal-buttons"><button id="cancelSave" class="btn-secondary">Cancel</button><button id="confirmSave">Save</button></div>
    </div>
  </div>

  <!-- NEW: Modal for saving the recording -->
  <div id="recordingNameModal" class="modal">
    <div class="modal-content">
      <h3>Save Recording</h3>
      <div>
        <label for="recordingNameInput">Filename:</label>
        <input type="text" id="recordingNameInput" placeholder="recording.webm">
      </div>
      <div class="modal-buttons">
        <button id="cancelRecordingSave" class="btn-secondary">Discard</button>
        <button id="confirmRecordingSave">Save</button>
      </div>
    </div>
  </div>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <!-- Main Application Script -->
  <script src="js/main.js" type="module"></script>
</body>
</html>
===== C:\Users\MSI\Desktop\PW\videosolution\README.md ===== 
"# videosolution" 

===== C:\Users\MSI\Desktop\PW\videosolution\source_code.txt ===== 
===== C:\Users\MSI\Desktop\PW\videosolution\index.html ===== 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Drawing & Recording Canvas</title>
    <!-- NEW: Add this line to link your new icon -->
  <l
===== C:\Users\MSI\Desktop\PW\videosolution\css\canvas.css ===== 
.canvas-container {
  position: relative;
  box-shadow: 0 4px 12px -1px rgba(0, 0, 0, 0.1);
  border-radius: 4px;
  width: 100%;
  max-width: 100%;
  max-height: 100%;
}

canvas {
  border: 1px solid var(--border-color);
  background: white;
  border-radius: 4px;
  touch-action: none;
  display: block;
  width: 100%;
  height: 100%;
}

/* --- NEW: Define the custom dot cursor --- */
/* This SVG creates a small black dot with a white outline */
.cursor-dot {
  /* The '6 6' part sets the hotspot to the center of the 12x12 SVG */
  cursor: url('data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg"><circle cx="6" cy="6" r="2.5" fill="%23000" stroke="white" stroke-width="1.5"/></svg>') 6 6, crosshair;
}

/* Define classes for other cursors for consistency */
.cursor-grab {
  cursor: grab;
}
.cursor-default {
  cursor: default;
}.
===== C:\Users\MSI\Desktop\PW\videosolution\css\main.css ===== 
:root {
  --primary-color: #2563eb;
  --bg-color: #f8fafc;
  --toolbar-bg: #ffffff;
  --border-color: #e2e8f0;
  --text-color: #334155;
  --text-light: #64748b;
  --button-hover-bg: #f1f5f9;
  --sidebar-width: 150px;
}

body {
  display: flex;
  margin: 0;
  font-family: system-ui, -apple-system, sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  overflow: hidden;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

.main-content {
  margin-left: var(--sidebar-width);
  width: calc(100% - var(--sidebar-width));
  height: 100vh;
  /* MODIFIED: Center the canvas container */
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  box-sizing: border-box;
  /* REMOVED: overflow-y: auto to prevent scrollbars */
}

/* DELETED: The .page-controls styles are no longer needed */.
===== C:\Users\MSI\Desktop\PW\videosolution\css\modal.css ===== 
.modal {
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.4);
  display: none; /* Changed to 'flex' by JS */
  align-items: center;
  justify-content: center;
}

.modal-content {
  background-color: #fefefe;
  padding: 30px;
  border-radius: 8px;
  width: 90%;
  max-width: 400px;
  position: relative;
  box-shadow: 0 4px 15px rgba(0,0,0,0.15);
}

.modal-content h3 {
  margin: 0 0 20px 0;
  text-align: center;
  font-size: 1.2rem;
  color: var(--text-color);
}

.modal-content div {
  margin: 15px 0;
}

.modal-content label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  font-size: 14px;
}

.modal-content input[type="number"],
.modal-content input[type="text"] {
  width: 100%;
  padding: 10px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 14px;
  box-sizing: border-box;
}

.modal-content p {
  margin: 15px 0;
  font-size: 12px;
  color: var(--text-light);
  text-align: center;
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.modal-buttons button {
  flex: 1;
}

.modal-buttons button.btn-secondary {
  background-color: var(--button-hover-bg);
  color: var(--text-color);
  border-color: var(--border-color);
}

.modal-buttons button.btn-secondary:hover {
    background-color: #e2e8f0;
}

.modal-buttons button:last-child {
  background-color: var(--primary-color);
  color: white;
  border-color: var(--primary-color);
}.
===== C:\Users\MSI\Desktop\PW\videosolution\css\toolbar.css ===== 
.sidebar {
  position: fixed;
  left: 0;
  top: 0;
  width: var(--sidebar-width);
  height: 100vh;
  padding: 5px 5px;
  background: var(--toolbar-bg);
  box-shadow: 1px 0 5px rgba(0,0,0,0.08);
  display: flex;
  flex-direction: column;
  gap: 0px;
  z-index: 100;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) transparent;
}

.sidebar::-webkit-scrollbar {
  width: 1px;
}
.sidebar::-webkit-scrollbar-track {
  background: transparent;
}
.sidebar::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 10px;
  border: 2px solid var(--toolbar-bg);
}
.sidebar::-webkit-scrollbar-thumb:hover {
  background-color: #cdd5e0;
}


.tool-group {
  display: flex;
  flex-direction: column;
  gap: 3px;
  padding: 12px 8px;
  border-bottom: 1px solid var(--border-color);
  width: 90%;
}

.tool-group:last-child {
  border-bottom: none;
}

.tool-group h4 {
    font-size: 0.6rem;
    color: var(--text-light);
    text-transform: uppercase;
    margin: 0 0 8px 2px;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.tool-group label {
  font-size: 10px;
  color: var(--text-color);
  margin: 0 0 4px 2px;
  font-weight: 500;
}

button, select {
  padding: 8px 12px;
  background: var(--button-hover-bg); 
  border: 1px solid var(--border-color);
  border-radius: 6px;
  cursor: pointer;
  font-size: 10px;
  transition: all 0.2s;
  user-select: none;
  white-space: nowrap;
  width: 100%;
  text-align: left;
  color: var(--text-color);
}

button {
    display: flex;
    align-items: center;
    gap: 10px;
}

button i {
    font-size: 0.8rem;
    width: 20px;
    text-align: center;
    color: var(--text-light);
    transition: color 0.2s;
}

button:hover, select:hover {
  background-color: #e2e8f0;
  border-color: #cbd5e1;
}

button.active {
  background: var(--primary-color);
  color: white;
  border-color: var(--primary-color);
}
button.active i {
    color: white;
}

#recordBtn:not(.recording) {
    border-color: #334155;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: var(--button-hover-bg);
  border-color: var(--border-color);
}

button.recording {
  background-color: #dc2626;
  color: rgb(255, 255, 255);
  border-color: #b91c1c;
  animation: pulse 1.5s infinite;
}
button.recording span {
    animation: text-pulse 1.5s infinite;
}

/* NEW: Style for the paused state button */
button.paused {
  background-color: #ffffff; /* White background */
  color: #334155; /* Dark text */
  border-color: #334155; /* Dark border to match default record button */
  animation: none; /* Make sure to stop the pulse animation */
}
button.paused i {
  color: #334155; /* Dark icon */
}
button.paused span {
    animation: none; /* Stop text pulse animation */
}


@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
  70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
  100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
}
@keyframes text-pulse {
  0% { opacity: 1; }
  50% { opacity: 0.6; }
  100% { opacity: 1; }
}

.control-row {
    display: flex;
    gap: 8px;
    align-items: flex-end;
}
.control-item {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.page-nav-buttons {
    display: flex;
    gap: 8px;
}
.page-nav-buttons button {
    flex: 1;
    justify-content: center;
    padding: 8px;
}
.page-nav-buttons button i {
    width: auto;
    margin: 0;
}

#pageInfo {
    display: block;
    text-align: center;
    font-size: 10px;
    color: var(--text-light);
    font-weight: 500;
    margin-top: 8px;
}


#waveformCanvas {
  display: none;
  background-color: #f1f5f9;
  border-radius: 4px;
  border: 1px solid var(--border-color);
  width: 100%;
}.
===== C:\Users\MSI\Desktop\PW\videosolution\js\config.js ===== 
// js/config.js

export const elements = {
  // Canvas
  canvas: document.getElementById("drawingCanvas"),

  // Toolbar
  selectToolBtn: document.getElementById('selectTool'),
  pencilBtn: document.getElementById('pencil'),
  eraserBtn: document.getElementById('eraser'),
  sizeSelect: document.getElementById('size'),
  colorSelect: document.getElementById('color'),
  
  // Object Controls
  addImageBtn: document.getElementById('addImageBtn'),
  imageInput: document.getElementById('imageInput'),
  addBackgroundBtn: document.getElementById('addBackgroundBtn'),
  backgroundInput: document.getElementById('backgroundInput'),
  removeBackgroundBtn: document.getElementById('removeBackgroundBtn'),

  // Recording
  recordBtn: document.getElementById('recordBtn'),
  stopBtn: document.getElementById('stopBtn'),
  waveformCanvas: document.getElementById('waveformCanvas'),
  
  // File Operations
  savePdfBtn: document.getElementById('savePdf'),

  // Page Controls
  prevPageBtn: document.getElementById('prevPage'),
  nextPageBtn: document.getElementById('nextPage'),
  pageInfo: document.getElementById('pageInfo'),
  
  // Canvas Size Modal
  customCanvasBtn: document.getElementById('customCanvasBtn'),
  canvasSizeModal: document.getElementById('canvasSizeModal'),
  cancelCanvasSizeBtn: document.getElementById('cancelCanvasSize'),
  confirmCanvasSizeBtn: document.getElementById('confirmCanvasSize'),
  canvasWidthInput: document.getElementById('canvasWidth'),
  canvasHeightInput: document.getElementById('canvasHeight'),
  setBrowserSizeBtn: document.getElementById('setBrowserSize'),

  // Filename Modal
  filenameModal: document.getElementById('filenameModal'),
  filenameInput: document.getElementById('filenameInput'),
  cancelSaveBtn: document.getElementById('cancelSave'),
  confirmSaveBtn: document.getElementById('confirmSave'),

  // NEW: Recording Save Modal
  recordingNameModal: document.getElementById('recordingNameModal'),
  recordingNameInput: document.getElementById('recordingNameInput'),
  confirmRecordingSaveBtn: document.getElementById('confirmRecordingSave'),
  cancelRecordingSaveBtn: document.getElementById('cancelRecordingSave'),
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\fileHandler.js ===== 
// js/fileHandler.js
import { elements } from './config.js';
import { getState, getCanvasContext, renderPage, renderPageForExport } from './canvas/index.js';

let fileHandle = null;

// Save drawing as a PDF
export const saveDrawing = async (forceSaveAs = false) => {
  const { jsPDF } = window.jspdf;
  const { canvas } = getCanvasContext();
  const state = getState();
  const totalPages = Math.max(state.pages.length, 1);

  const performSave = async (fileName) => {
    const pdf = new jsPDF({
      orientation: canvas.width > canvas.height ? 'l' : 'p',
      unit: 'px',
      format: [canvas.width, canvas.height]
    });

    for (let i = 0; i < totalPages; i++) {
      if (i > 0) pdf.addPage([canvas.width, canvas.height]);
      
      renderPageForExport(i);
      
      const imgData = canvas.toDataURL('image/jpeg', 1.0);
      pdf.addImage(imgData, 'JPEG', 0, 0, canvas.width, canvas.height);
    }
    
    renderPage(); // Restore current page view

    try {
      if ('showSaveFilePicker' in window && (!fileHandle || forceSaveAs)) {
        // MODIFIED: Corrected the function name by removing the extra "File"
        fileHandle = await window.showSaveFilePicker({
          suggestedName: fileName,
          types: [{ description: 'PDF Files', accept: { 'application/pdf': ['.pdf'] } }],
        });
      }
      
      if (fileHandle) {
        const writable = await fileHandle.createWritable();
        await writable.write(pdf.output('blob'));
        await writable.close();
      } else {
        pdf.save(fileName);
      }
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error("Save failed:", err);
        alert("File save failed. See console for details.");
      }
      fileHandle = null;
    }
  };

  elements.filenameInput.value = fileHandle ? fileHandle.name : 'drawing.pdf';
  elements.filenameModal.style.display = 'flex';
  elements.filenameInput.focus();
  elements.filenameInput.select();

  return new Promise((resolve) => {
    const confirmHandler = () => {
      cleanup();
      const fileName = elements.filenameInput.value || 'drawing.pdf';
      performSave(fileName).then(() => resolve(true));
    };

    const cancelHandler = () => {
      cleanup();
      resolve(false);
    };

    const cleanup = () => {
      elements.filenameModal.style.display = 'none';
      elements.confirmSaveBtn.removeEventListener('click', confirmHandler);
      elements.cancelSaveBtn.removeEventListener('click', cancelHandler);
    };

    elements.confirmSaveBtn.addEventListener('click', confirmHandler, { once: true });
    elements.cancelSaveBtn.addEventListener('click', cancelHandler, { once: true });
  });
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\main.js ===== 
// js/main.js
import { initCanvas, setBackgroundImage, setCanvasSize } from './canvas/index.js';
import { initUI } from './ui.js';

document.addEventListener('DOMContentLoaded', async () => {
  initCanvas();
  initUI();

  const savedWidth = localStorage.getItem('canvasWidth');
  const savedHeight = localStorage.getItem('canvasHeight');

  if (savedWidth && savedHeight) {
    console.log(`Loading saved canvas size: ${savedWidth}x${savedHeight}`);
    setCanvasSize(parseInt(savedWidth, 10), parseInt(savedHeight, 10));
  } else {
    console.log('No saved size, using default 1280x720.');
    setCanvasSize(1280, 720);
  }

  const savedBackground = localStorage.getItem('canvasBackground');
  if (savedBackground) {
    console.log('Found saved background, loading...');
    await setBackgroundImage(savedBackground);
  } else {
    console.log('No saved background, loading default...');
    await setBackgroundImage('images/background.png');
  }
});.
===== C:\Users\MSI\Desktop\PW\videosolution\js\recorder.js ===== 
// js/recorder.js
import { getCanvasContext } from './canvas/index.js';
import * as waveform from './waveform.js';

let mediaRecorder;
let recordedChunks = [];
let audioStream;
let videoStream;
let isPaused = false;

const pinger = {
    snapshot: null,
    intervalId: null,
    async start() {
        if (this.intervalId) return;
        const { canvas, ctx } = getCanvasContext();
        if (!canvas || !ctx) return;
        const img = new Image();
        img.src = canvas.toDataURL();
        await new Promise(resolve => { img.onload = resolve; });
        this.snapshot = img;
        const frameRate = 30;
        this.intervalId = setInterval(() => {
            if (this.snapshot) {
                ctx.drawImage(this.snapshot, 0, 0, canvas.width, canvas.height);
            }
        }, 1000 / frameRate);
    },
    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
            this.snapshot = null;
        }
    }
};

export const startPinger = () => pinger.start();
export const stopPinger = () => pinger.stop();

export const isRecording = () => mediaRecorder && mediaRecorder.state !== 'inactive';
export const getIsPaused = () => isPaused;

const handleDataAvailable = (event) => {
  if (event.data.size > 0) {
    recordedChunks.push(event.data);
  }
};

// DELETED: The old downloadVideo function is removed.

export const startRecording = async () => {
  if (isRecording()) return;
  recordedChunks = []; // Clear chunks from previous recordings

  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    const { canvas } = getCanvasContext();
    videoStream = canvas.captureStream(60);
    const combinedStream = new MediaStream([...videoStream.getTracks(), ...audioStream.getTracks()]);

    waveform.init(audioStream);
    waveform.start();

    const options = { 
      mimeType: 'video/webm; codecs=vp9,opus',
      videoBitsPerSecond: 8000000,
      audioBitsPerSecond: 128000,
    };
    
    mediaRecorder = new MediaRecorder(combinedStream, options);
    mediaRecorder.ondataavailable = handleDataAvailable;
    // The onstop event will now resolve the promise in stopRecording()
    
    mediaRecorder.start();
    isPaused = false;
    pinger.start();
    console.log('Recording started.');
  } catch (err) {
    console.error("Could not start recording:", err);
    if (audioStream) audioStream.getTracks().forEach(track => track.stop());
    throw new Error('Microphone access was denied. Cannot record audio.');
  }
};

export const pauseRecording = () => {
    if (!isRecording() || isPaused) return;
    mediaRecorder.pause();
    isPaused = true;
    pinger.stop();
    console.log('Recording paused.');
};

export const resumeRecording = () => {
    if (!isRecording() || !isPaused) return;
    mediaRecorder.resume();
    isPaused = false;
    pinger.start();
    console.log('Recording resumed.');
};

// MODIFIED: This function now returns a Promise with the video blob
export const stopRecording = () => {
  if (!isRecording()) return Promise.resolve(null);

  return new Promise((resolve) => {
    // Set the onstop event handler to resolve the promise
    mediaRecorder.onstop = () => {
      pinger.stop();
      waveform.stop();
      if (audioStream) audioStream.getTracks().forEach(track => track.stop());
      if (videoStream) videoStream.getTracks().forEach(track => track.stop());
      isPaused = false;
      console.log('Recording stopped. Data compiled.');
      
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      resolve(blob);
    };

    // Trigger the onstop event
    if (mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
  });
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\ui.js ===== 
// js/ui.js
import { elements } from './config.js';
import * as canvas from './canvas/index.js';
import * as file from './fileHandler.js';
import * as recorder from './recorder.js';

const updatePageInfo = () => {
    const { currentPage, pages } = canvas.getState();
    const totalPages = Math.max(pages.length, 1);
    elements.pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    elements.prevPageBtn.disabled = currentPage === 1;
    elements.nextPageBtn.disabled = currentPage >= 200;
};

const setupToolButtons = () => {
    const tools = [
        { btn: elements.selectToolBtn, name: 'select', cursorClass: 'cursor-default' },
        { btn: elements.pencilBtn, name: 'pencil', cursorClass: 'cursor-dot' },
        { btn: elements.eraserBtn, name: 'eraser', cursorClass: 'cursor-grab' },
    ];
    const cursorClasses = tools.map(t => t.cursorClass);

    tools.forEach(tool => {
        tool.btn.addEventListener('click', () => {
            canvas.setTool(tool.name);
            elements.canvas.classList.remove(...cursorClasses);
            elements.canvas.classList.add(tool.cursorClass);
            tools.forEach(t => t.btn.classList.remove('active'));
            tool.btn.classList.add('active');
        });
    });
};

const setupCanvasEventListeners = () => {
    const { canvas: canvasEl } = elements;
    canvasEl.addEventListener('pointerdown', (e) => {
        if (recorder.isRecording()) recorder.stopPinger();
        if (e.button === 2) {
            canvas.setRightMouseDown(true);
            elements.eraserBtn.click();
        }
        canvas.onPointerDown(e);
    });
    canvasEl.addEventListener('pointermove', canvas.onPointerMove);
    const onPointerUpOrOut = (e) => {
        if (recorder.isRecording() && !recorder.getIsPaused()) recorder.startPinger();
        if (canvas.getRightMouseDown()) {
            canvas.setRightMouseDown(false);
            elements.pencilBtn.click();
        }
        canvas.onPointerUp(e);
    };
    canvasEl.addEventListener('pointerup', onPointerUpOrOut);
    canvasEl.addEventListener('pointerleave', () => { if (!canvas.getState().isDrawing) canvas.renderPage(); });
    canvasEl.addEventListener('contextmenu', (e) => e.preventDefault());
};

const setupActionButtons = () => {
    elements.savePdfBtn.addEventListener('click', () => file.saveDrawing(false));
};

// MODIFIED: This function now handles the three visual states for recording
const updateRecordingUI = () => {
    const { recordBtn, stopBtn } = elements;
    const recordText = recordBtn.querySelector('span');
    const recordIcon = recordBtn.querySelector('i');

    if (!recorder.isRecording()) {
        // State: STOPPED
        recordBtn.classList.remove('recording', 'paused'); // Remove all recording classes
        recordIcon.className = 'fa-solid fa-microphone';
        recordText.textContent = 'Record';
        recordBtn.title = 'Start Recording';
        stopBtn.style.display = 'none';
    } else {
        // State: RECORDING or PAUSED
        stopBtn.style.display = 'flex';
            if (recorder.getIsPaused()) {
            // State: PAUSED
            recordBtn.classList.remove('recording'); // Remove red pulse
            recordBtn.classList.add('paused');      // Add white style
            recordIcon.className = 'fa-solid fa-play';
            recordText.textContent = 'R';
            recordBtn.title = 'Resume Recording';
        } else {
            // State: ACTIVELY RECORDING
            recordBtn.classList.remove('paused');   // Remove white style
            recordBtn.classList.add('recording');   // Add red pulse
            recordIcon.className = 'fa-solid fa-pause';
            recordText.textContent = 'P';
            recordBtn.title = 'Pause Recording';
        }
    }
};

const handleRecordingSave = (blob) => {
    const { recordingNameModal, recordingNameInput, confirmRecordingSaveBtn, cancelRecordingSaveBtn } = elements;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '');
    recordingNameInput.value = `recording-${timestamp}.webm`;
    recordingNameModal.style.display = 'flex';
    recordingNameInput.focus();
    recordingNameInput.select();
    const cleanup = () => {
        recordingNameModal.style.display = 'none';
        updateRecordingUI();
    };
    const onConfirm = () => {
        const filename = recordingNameInput.value || recordingNameInput.placeholder;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        cleanup();
    };
    const onCancel = () => cleanup();
    confirmRecordingSaveBtn.onclick = onConfirm;
    cancelRecordingSaveBtn.onclick = onCancel;
};

const setupRecording = () => {
    elements.recordBtn.addEventListener('click', async () => {
        if (!recorder.isRecording()) {
            try { await recorder.startRecording(); } 
            catch (error) { alert(error.message); }
        } else {
            recorder.getIsPaused() ? recorder.resumeRecording() : recorder.pauseRecording();
        }
        updateRecordingUI();
    });
    elements.stopBtn.addEventListener('click', async () => {
        const blob = await recorder.stopRecording();
        if (blob && blob.size > 0) {
            handleRecordingSave(blob);
        } else {
            updateRecordingUI();
        }
    });
};

const setupImageControls = () => {
    elements.addImageBtn.addEventListener('click', () => elements.imageInput.click());
    elements.imageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => canvas.addImage(event.target.result);
        reader.readAsDataURL(file);
        e.target.value = '';
    });
};

const setupBackgroundControls = () => {
    elements.addBackgroundBtn.addEventListener('click', () => elements.backgroundInput.click());
    elements.backgroundInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            localStorage.setItem('canvasBackground', event.target.result);
            canvas.setBackgroundImage(event.target.result);
        };
        reader.readAsDataURL(file);
        e.target.value = '';
    });
    elements.removeBackgroundBtn.addEventListener('click', () => {
        localStorage.removeItem('canvasBackground');
        canvas.removeBackgroundImage();
    });
};

const setupPageControls = () => {
    elements.prevPageBtn.addEventListener('click', () => { canvas.changePage('prev'); updatePageInfo(); });
    elements.nextPageBtn.addEventListener('click', () => { canvas.changePage('next'); updatePageInfo(); });
};

const setupCanvasSizeModal = () => {
    elements.customCanvasBtn.addEventListener('click', () => {
        const { width, height } = canvas.getCanvasContext().canvas;
        elements.canvasWidthInput.value = width;
        elements.canvasHeightInput.value = height;
        elements.canvasSizeModal.style.display = 'flex';
    });
    elements.cancelCanvasSizeBtn.addEventListener('click', () => { elements.canvasSizeModal.style.display = 'none'; });
    elements.confirmCanvasSizeBtn.addEventListener('click', () => {
        const newWidth = parseInt(elements.canvasWidthInput.value, 10);
        const newHeight = parseInt(elements.canvasHeightInput.value, 10);
        if (newWidth && newHeight) {
            canvas.setCanvasSize(newWidth, newHeight);
        }
        elements.canvasSizeModal.style.display = 'none';
    });
    elements.setBrowserSizeBtn.addEventListener('click', () => {
      canvas.adjustCanvasToBrowserSize();
      elements.canvasSizeModal.style.display = 'none';
    });
};

const setupKeyboardShortcuts = () => {
    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
        const isCtrl = e.ctrlKey || e.metaKey;
        if (!isCtrl) {
            switch (e.key.toLowerCase()) {
                case 'p': e.preventDefault(); elements.pencilBtn.click(); break;
                case 'e': e.preventDefault(); elements.eraserBtn.click(); break;
                case 'v': e.preventDefault(); elements.selectToolBtn.click(); break;
                case 'delete': case 'backspace': e.preventDefault(); canvas.deleteSelectedObject(); break;
            }
        }
        if (isCtrl && e.key.toLowerCase() === 's') {
            e.preventDefault();
            file.saveDrawing(e.shiftKey);
        }
    });
};

export const initUI = () => {
    setupToolButtons();
    setupCanvasEventListeners();
    setupActionButtons();
    setupRecording();
    setupImageControls();
    setupBackgroundControls();
    setupPageControls();
    setupCanvasSizeModal();
    setupKeyboardShortcuts();
    updatePageInfo();
    elements.pencilBtn.click();
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\waveform.js ===== 
// js/waveform.js
import { elements } from './config.js';

let audioContext;
let analyser;
let source;
let dataArray;
let animationFrameId;

const { waveformCanvas } = elements;
const ctx = waveformCanvas.getContext('2d');

/**
 * Initializes the Web Audio API components.
 * @param {MediaStream} stream The audio stream from the microphone.
 */
export const init = (stream) => {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 256; // Smaller size for better performance/simpler waveform

  source = audioContext.createMediaStreamSource(stream);
  source.connect(analyser);

  const bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);
};

/**
 * The drawing loop that visualizes the waveform.
 */
const draw = () => {
  animationFrameId = requestAnimationFrame(draw);

  analyser.getByteTimeDomainData(dataArray);

  ctx.fillStyle = '#f1f5f9';
  ctx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#64748b'; // A calm, greyish-blue
  ctx.beginPath();

  const sliceWidth = waveformCanvas.width * 1.0 / analyser.frequencyBinCount;
  let x = 0;

  for (let i = 0; i < analyser.frequencyBinCount; i++) {
    const v = dataArray[i] / 128.0; // Normalize to 0-2 range
    const y = v * waveformCanvas.height / 2;

    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }

    x += sliceWidth;
  }

  ctx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
  ctx.stroke();
};

/**
 * Starts displaying the waveform.
 */
export const start = () => {
  waveformCanvas.style.display = 'block';
  draw();
};

/**
 * Stops displaying the waveform and cleans up.
 */
export const stop = () => {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  waveformCanvas.style.display = 'none';
  if (audioContext && audioContext.state !== 'closed') {
    audioContext.close();
  }
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\canvas\events.js ===== 
// js/canvas/events.js
import { elements } from '../config.js';
import { state } from './state.js';
import { renderPage } from './renderer.js';
import { getObjectAtPosition, getHandleAtPosition, isPointOnStroke } from './interactions.js';

// REMOVED: No more need for undo callback

const getTransformedCoordinates = (e) => {
    const rect = elements.canvas.getBoundingClientRect();
    // NEW: Calculate coordinates based on the scaled canvas
    const scaleX = elements.canvas.width / rect.width;
    const scaleY = elements.canvas.height / rect.height;

    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY,
    };
};

const getSmoothedCoordinates = (e) => {
    const rawPoint = getTransformedCoordinates(e);
    const smoothedX = state.lastPoint.x + (rawPoint.x - state.lastPoint.x) * (1 - state.DAMPING_FACTOR);
    const smoothedY = state.lastPoint.y + (rawPoint.y - state.lastPoint.y) * (1 - state.DAMPING_FACTOR);
    state.lastPoint = { x: smoothedX, y: smoothedY };
    return { x: smoothedX, y: smoothedY };
};

const eraseAtPoint = (point) => {
    const pageIndex = state.currentPage - 1;
    let hasChanged = false;
    state.pages[pageIndex].forEach(obj => {
        if (obj.type === 'stroke' && !obj.isErased && isPointOnStroke(point, obj)) {
            obj.isErased = true;
            hasChanged = true;
        }
    });
    if (hasChanged) {
        renderPage();
    }
};

export const onPointerDown = (e) => {
    state.isDrawing = true;
    state.lastPoint = getTransformedCoordinates(e); // Use transformed coords

    if (state.tool === 'select') {
        const handle = state.selectedObject ? getHandleAtPosition(state.lastPoint, state.selectedObject) : null;
        if (handle) {
            state.actionState = 'resizing';
            state.resizeHandle = handle;
        } else {
            const object = getObjectAtPosition(state.lastPoint);
            state.selectedObject = object;
            if (object) {
                state.actionState = 'moving';
                state.startDragOffset = { x: state.lastPoint.x - object.x, y: state.lastPoint.y - object.y };
            } else {
                state.actionState = null;
            }
        }
    } else if (state.tool === 'pencil') {
        state.currentStroke = {
            type: 'stroke', id: Date.now() + Math.random(),
            points: [state.lastPoint], color: elements.colorSelect.value,
            width: parseInt(elements.sizeSelect.value, 10), isErased: false,
        };
    }
    renderPage();
};

export const onPointerMove = (e) => {
    const currentPoint = state.tool === 'pencil' ? getSmoothedCoordinates(e) : getTransformedCoordinates(e);
    
    if (state.tool === 'select' && !state.isDrawing) {
        const handle = state.selectedObject ? getHandleAtPosition(currentPoint, state.selectedObject) : null;
        if (handle) {
            if (['tl', 'br'].includes(handle)) elements.canvas.style.cursor = 'nwse-resize';
            else if (['tr', 'bl'].includes(handle)) elements.canvas.style.cursor = 'nesw-resize';
            else if (['tm', 'bm'].includes(handle)) elements.canvas.style.cursor = 'ns-resize';
            else elements.canvas.style.cursor = 'ew-resize';
        } else {
            elements.canvas.style.cursor = getObjectAtPosition(currentPoint) ? 'move' : 'default';
        }
    }

    if (!state.isDrawing) return;

    if (state.tool === 'select' && state.selectedObject) {
        const obj = state.selectedObject;
        if (state.actionState === 'moving') {
            obj.x = currentPoint.x - state.startDragOffset.x;
            obj.y = currentPoint.y - state.startDragOffset.y;
        } else if (state.actionState === 'resizing') {
            const { x, y, width, height } = obj;
            const originalRight = x + width, originalBottom = y + height;
            if (state.resizeHandle.includes('l')) { obj.width = originalRight - currentPoint.x; obj.x = currentPoint.x; }
            if (state.resizeHandle.includes('r')) { obj.width = currentPoint.x - x; }
            if (state.resizeHandle.includes('t')) { obj.height = originalBottom - currentPoint.y; obj.y = currentPoint.y; }
            if (state.resizeHandle.includes('b')) { obj.height = currentPoint.y - y; }
            if (obj.width < 10) obj.width = 10;
            if (obj.height < 10) obj.height = 10;
        }
    } else if (state.tool === 'pencil' && state.currentStroke) {
        state.currentStroke.points.push(currentPoint);
    } else if (state.tool === 'eraser') {
        eraseAtPoint(currentPoint);
    }
    renderPage();
};

export const onPointerUp = () => {
    if (!state.isDrawing) return;
    if (state.tool === 'pencil' && state.currentStroke && state.currentStroke.points.length > 1) {
        const pageIndex = state.currentPage - 1;
        state.pages[pageIndex].push(state.currentStroke);
    }
    
    state.isDrawing = false;
    state.actionState = null;
    state.resizeHandle = null;
    state.currentStroke = null;
    renderPage();
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\canvas\index.js ===== 
// js/canvas/index.js
import { elements } from '../config.js';
import { state, resetState, getState } from './state.js';
import { renderPage, renderPageForExport } from './renderer.js';
import * as events from './events.js';

// --- PUBLIC API ---
export { onPointerDown, onPointerMove, onPointerUp } from './events.js';
export { renderPage, renderPageForExport };
export { getState };

export const initCanvas = () => {
  resetState();
  // Set default on load
  setCanvasSize(1280, 720);
};

export const getCanvasContext = () => ({ canvas: elements.canvas, ctx: elements.canvas.getContext('2d') });

export const setTool = (toolName) => { 
    state.tool = toolName;
    state.selectedObject = null;
    if (toolName !== 'select') {
        renderPage();
    }
};

export const addImage = (imageDataUrl) => {
    const img = new Image();
    img.src = imageDataUrl;
    img.onload = () => {
        const pageIndex = state.currentPage - 1;
        const canvasWidth = elements.canvas.width;
        const canvasHeight = elements.canvas.height;
        const padding = 50;
        const maxWidth = canvasWidth - padding * 2;
        const maxHeight = canvasHeight - padding * 2;

        let newWidth = img.width;
        let newHeight = img.height;
        
        if (newWidth > maxWidth || newHeight > maxHeight) {
            const ratio = Math.min(maxWidth / newWidth, maxHeight / newHeight);
            newWidth *= ratio;
            newHeight *= ratio;
        }

        const newImage = {
            type: 'image', id: Date.now(), src: imageDataUrl,
            x: (canvasWidth - newWidth) / 2, 
            y: (canvasHeight - newHeight) / 2, 
            width: newWidth, 
            height: newHeight,
            img,
        };

        if (!state.pages[pageIndex]) state.pages[pageIndex] = [];
        state.pages[pageIndex].push(newImage);
        state.selectedObject = newImage;
        setTool('select');
        elements.selectToolBtn.click();
        renderPage();
    };
};

export const deleteSelectedObject = () => {
    if (state.tool === 'select' && state.selectedObject) {
        const pageIndex = state.currentPage - 1;
        state.pages[pageIndex] = state.pages[pageIndex].filter(obj => obj.id !== state.selectedObject.id);
        state.selectedObject = null;
        renderPage();
    }
};

// --- MODIFIED: This function is rewritten to be more robust ---
export const changePage = (direction) => {
  // 1. Deselect any object before changing pages.
  state.selectedObject = null;

  // 2. Update the page number based on the direction.
  if (direction === 'prev' && state.currentPage > 1) {
    state.currentPage--;
  } else if (direction === 'next') {
    state.currentPage++;
    // Ensure the data array exists for the new page.
    const newPageIndex = state.currentPage - 1;
    if (newPageIndex >= state.pages.length) {
      state.pages.push([]);
    }
  }

  // 3. CRUCIAL FIX: Immediately re-render the canvas.
  // This clears the old content and draws the new page's content (or an empty page).
  renderPage();
};


export const setBackgroundImage = async (imageDataUrl) => {
  if (!imageDataUrl) { state.backgroundImage = null; renderPage(); return; }
  try {
      const img = new Image();
      img.src = imageDataUrl;
      await img.decode(); 
      state.backgroundImage = img;
      renderPage();
  } catch (error) { console.error(error); state.backgroundImage = null; }
};

export const removeBackgroundImage = () => { state.backgroundImage = null; renderPage(); };

export const setCanvasSize = (width, height) => {
  elements.canvas.width = width;
  elements.canvas.height = height;
  elements.canvas.style.aspectRatio = `${width} / ${height}`;
  localStorage.setItem('canvasWidth', width);
  localStorage.setItem('canvasHeight', height);
  resetState();
  renderPage();
};

export const adjustCanvasToBrowserSize = () => {
  const mainContent = document.querySelector('.main-content');
  const rect = mainContent.getBoundingClientRect();
  setCanvasSize(rect.width, rect.height);
};

export const setRightMouseDown = (isDown) => { state.isRightMouseDown = isDown; };
export const getRightMouseDown = () => state.isRightMouseDown;.
===== C:\Users\MSI\Desktop\PW\videosolution\js\canvas\interactions.js ===== 
// js/canvas/interactions.js
import { getState } from "./state.js";

export const getObjectAtPosition = (point) => {
    const state = getState();
    const pageIndex = state.currentPage - 1;
    const objects = state.pages[pageIndex] || [];
    for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj.type === 'image') {
            if (point.x >= obj.x && point.x <= obj.x + obj.width &&
                point.y >= obj.y && point.y <= obj.y + obj.height) {
                return obj;
            }
        }
    }
    return null;
};

export const getResizeHandles = (imageObj) => {
    const { x, y, width, height } = imageObj;
    return {
        tl: { x: x, y: y }, tr: { x: x + width, y: y },
        bl: { x: x, y: y + height }, br: { x: x + width, y: y + height },
        tm: { x: x + width / 2, y: y }, bm: { x: x + width / 2, y: y + height },
        ml: { x: x, y: y + height / 2 }, mr: { x: x + width, y: y + height / 2 },
    };
};

export const getHandleAtPosition = (point, imageObj) => {
    const handles = getResizeHandles(imageObj);
    const handleSize = 10;
    for (const pos in handles) {
        const handle = handles[pos];
        if (Math.abs(point.x - handle.x) < handleSize / 2 &&
            Math.abs(point.y - handle.y) < handleSize / 2) {
            return pos;
        }
    }
    return null;
};

export const isPointOnStroke = (point, stroke, tolerance = 10) => {
  if (!stroke || !stroke.points || stroke.points.length < 2) return false;
  const effectiveTolerance = Math.max(tolerance, stroke.width / 2 + 5);
  for (let i = 0; i < stroke.points.length - 1; i++) {
    const p1 = stroke.points[i];
    const p2 = stroke.points[i+1];
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    if (dx === 0 && dy === 0) continue;
    const t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / (dx * dx + dy * dy);
    const closestT = Math.max(0, Math.min(1, t));
    const closestX = p1.x + closestT * dx;
    const closestY = p1.y + closestT * dy;
    const distSq = (point.x - closestX)**2 + (point.y - closestY)**2;
    if (distSq < effectiveTolerance**2) return true;
  }
  return false;
};.
===== C:\Users\MSI\Desktop\PW\videosolution\js\canvas\renderer.js ===== 
// js/canvas/renderer.js
import { elements } from '../config.js';
import { getState } from './state.js';
import { getResizeHandles } from './interactions.js';

const { canvas } = elements;
const ctx = canvas.getContext("2d", { willReadFrequently: true });

const drawStroke = (stroke) => {
  if (!stroke || stroke.points.length < 2) return;
  ctx.globalCompositeOperation = 'source-over';
  ctx.strokeStyle = stroke.color;
  ctx.lineWidth = stroke.width;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
  for (let i = 1; i < stroke.points.length - 1; i++) {
    const midPoint = {
      x: (stroke.points[i].x + stroke.points[i + 1].x) / 2,
      y: (stroke.points[i].y + stroke.points[i + 1].y) / 2,
    };
    ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, midPoint.x, midPoint.y);
  }
  ctx.lineTo(stroke.points[stroke.points.length - 1].x, stroke.points[stroke.points.length - 1].y);
  ctx.stroke();
};

const drawImage = (imageObj) => {
    if (imageObj.img && imageObj.img.complete) {
        ctx.drawImage(imageObj.img, imageObj.x, imageObj.y, imageObj.width, imageObj.height);
    }
};

const drawSelectionBox = (obj) => {
    if (obj.type !== 'image') return;
    ctx.strokeStyle = 'rgba(37, 99, 235, 0.9)';
    ctx.lineWidth = 1.5 / (window.devicePixelRatio || 1); // Keep selection box thin
    ctx.setLineDash([6, 3]);
    ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
    ctx.setLineDash([]);
    const handleSize = 8;
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'rgba(37, 99, 235, 0.9)';
    ctx.lineWidth = 1;
    const handles = getResizeHandles(obj);
    for (const pos in handles) {
        const handle = handles[pos];
        ctx.fillRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
        ctx.strokeRect(handle.x - handleSize / 2, handle.y - handleSize / 2, handleSize, handleSize);
    }
};

const clearCanvas = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
};

export const renderPage = () => {
  clearCanvas();
  const state = getState();
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (state.backgroundImage) {
    // MODIFIED: Draw the background to fill the entire canvas resolution
    ctx.drawImage(state.backgroundImage, 0, 0, canvas.width, canvas.height);
  }
  
  const pageIndex = state.currentPage - 1;
  if (state.pages[pageIndex]) {
    state.pages[pageIndex].forEach(obj => {
        if (obj.type === 'stroke' && !obj.isErased) {
            drawStroke(obj);
        } else if (obj.type === 'image') {
            drawImage(obj);
        }
    });
  }

  if (state.selectedObject) {
      drawSelectionBox(state.selectedObject);
  }

  if (state.isDrawing && state.currentStroke) {
      drawStroke(state.currentStroke);
  }
};

export const renderPageForExport = (pageIndex) => {
  clearCanvas();
  const state = getState();
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (state.backgroundImage) {
    // MODIFIED: Also fix the export rendering
    ctx.drawImage(state.backgroundImage, 0, 0, canvas.width, canvas.height);
  }
  if (state.pages[pageIndex]) {
    state.pages[pageIndex].forEach(obj => {
      if (obj.type === 'stroke' && !obj.isErased) drawStroke(obj);
      else if (obj.type === 'image') drawImage(obj);
    });
  }
};

// This function is no longer needed here, as sizing is handled in index.js
// export const setupCanvasScaling = () => { ... };.
===== C:\Users\MSI\Desktop\PW\videosolution\js\canvas\state.js ===== 
// js/canvas/state.js
export const state = {
  isDrawing: false,
  isRightMouseDown: false,
  tool: 'pencil', // 'pencil', 'eraser', 'select'
  currentPage: 1,
  pages: [[]], // e.g., [[{type: 'stroke', ...}, {type: 'image', ...}]]
  // REMOVED: undoStack and redoStack are gone
  backgroundImage: null,
  
  // State for select tool
  selectedObject: null,
  actionState: null, // null, 'moving', 'resizing'
  resizeHandle: null, // e.g., 'tl', 'br', 'tm', etc.
  startDragOffset: { x: 0, y: 0 },

  // Stroke-specific state
  currentStroke: null,
  lastPoint: { x: 0, y: 0 },
  DAMPING_FACTOR: 0.5,
};

export const getState = () => state;

export function resetState() {
  state.currentPage = 1;
  state.pages = [[]];
  state.selectedObject = null;
  state.currentStroke = null;
  state.isDrawing = false;
}.
